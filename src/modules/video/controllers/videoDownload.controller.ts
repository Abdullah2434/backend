import { Request, Response } from "express";
import VideoService from "../services/video.service";
import VideoSchedule from "../../../models/VideoSchedule";
import VideoScheduleService from "../../../services/videoSchedule.service";
import { AutoSocialPostingService } from "../../../services/autoSocialPosting.service";
import WorkflowHistory from "../../../models/WorkflowHistory";
import PendingCaptions from "../../../models/PendingCaptions";
import { notificationService } from "../../../services/notification.service";
import {
  validateDownloadVideo,
  validateUpdateVideoStatus,
  validateDownloadProxyQuery,
} from "../../../validations/video.validations";
import {
  extractToken,
  getCurrentUser,
  isValidScheduleContext,
  getErrorStatus,
} from "../../../utils/videoHelpers";
import AuthService from "../../../services/auth.service";

const videoService = new VideoService();
const authService = new AuthService();

/**
 * Download video from URL and upload to S3
 * POST /api/video/download
 */
export async function download(req: Request, res: Response) {
  try {
    const validationResult = validateDownloadVideo(req.body);
    if (!validationResult.success) {
      return res.status(400).json({
        success: false,
        message: "Validation failed",
        errors: validationResult.errors,
      });
    }

    const {
      videoUrl,
      email,
      title,
      executionId,
      scheduleId,
      trendIndex,
      captions,
    } = validationResult.data!;

    // Get user ID for notifications
    const user = await videoService.getUserByEmail(email);
    if (!user) {
      return res.status(404).json({
        success: false,
        message: "User not found",
      });
    }

    // Send initial notification
    notificationService.notifyVideoDownloadProgress(
      user._id.toString(),
      "download",
      "progress",
      {
        message: "Starting video download...",
      }
    );

    const result = await videoService.downloadAndUploadVideo(
      videoUrl,
      email,
      title
    );

    // Mark whether this video was auto-generated (scheduled) or manual
    try {
      await videoService.updateVideoAutoGenerated(
        result.videoId,
        Boolean(scheduleId)
      );
    } catch (autoGenErr) {}

    // If captions are provided in the request (manual/custom flow), store them on the video
    try {
      if (captions && typeof captions === "object") {
        await videoService.updateVideoCaptions(result.videoId, {
          instagram_caption: captions.instagram_caption,
          facebook_caption: captions.facebook_caption,
          linkedin_caption: captions.linkedin_caption,
          twitter_caption: captions.twitter_caption,
          tiktok_caption: captions.tiktok_caption,
          youtube_caption: captions.youtube_caption,
        });
      } else {
        // Otherwise, try to consume server-stored pending captions (generated at createVideo)
        try {
          const pending = await PendingCaptions.findOne({ email, title });
          if (pending?.captions) {
            await videoService.updateVideoCaptions(result.videoId, {
              instagram_caption: pending.captions.instagram_caption,
              facebook_caption: pending.captions.facebook_caption,
              linkedin_caption: pending.captions.linkedin_caption,
              twitter_caption: pending.captions.twitter_caption,
              tiktok_caption: pending.captions.tiktok_caption,
              youtube_caption: pending.captions.youtube_caption,
            });

            // best-effort cleanup
            try {
              await PendingCaptions.deleteOne({ _id: (pending as any)._id });
            } catch {}
          }
        } catch (consumeErr) {
          console.warn(
            "No pending captions found or failed to consume:",
            consumeErr
          );
        }
      }
    } catch (capErr) {}

    // Update workflow history if executionId is provided
    if (executionId) {
      try {
        await WorkflowHistory.findOneAndUpdate(
          { executionId },
          {
            status: "completed",
            completedAt: new Date(),
          }
        );
      } catch (workflowError) {}
    }

    // Send success notification
    notificationService.notifyVideoDownloadProgress(
      user._id.toString(),
      "complete",
      "success",
      {
        message: "Video downloaded and uploaded successfully!",
        videoId: result.videoId,
        title: result.title,
        size: result.size,
      }
    );

    // If schedule context is provided, mark schedule item completed and trigger auto-posting
    if (isValidScheduleContext(scheduleId, trendIndex)) {
      // Run asynchronously; do not delay the response
      (async () => {
        try {
          // Idempotency: if already completed, skip posting
          const schedule = await VideoSchedule.findById(scheduleId);
          if (!schedule) {
            return;
          }

          const trend = schedule.generatedTrends?.[Number(trendIndex)];
          if (!trend) {
            return;
          }

          if (trend.status === "completed" && trend.videoId) {
            return;
          }

          // Update schedule status to completed and set videoId
          const videoScheduleService = new VideoScheduleService();
          await videoScheduleService.updateVideoStatus(
            String(scheduleId),
            Number(trendIndex),
            "completed",
            result.videoId
          );

          // Prefer a signed S3 download URL if available
          const readyVideo = await videoService.getVideoWithDownloadUrl(
            result.videoId
          );
          const downloadableUrl = (readyVideo as any)?.downloadUrl || videoUrl;

          // Trigger auto social posting using existing manual code paths
          const autoPoster = new AutoSocialPostingService();
          await autoPoster.postVideoToSocialMedia({
            userId: user._id.toString(),
            scheduleId: String(scheduleId),
            trendIndex: Number(trendIndex),
            videoUrl: downloadableUrl,
            videoTitle: result.title,
          });
        } catch (autoErr: any) {}
      })();
    }

    return res.json({
      success: true,
      message: "Video downloaded and uploaded successfully",
      data: result,
    });
  } catch (e: any) {
    // If schedule context is present, mark schedule item as failed
    try {
      const { scheduleId, trendIndex } = req.body as any;
      if (isValidScheduleContext(scheduleId, trendIndex)) {
        const videoScheduleService = new VideoScheduleService();
        await videoScheduleService.updateVideoStatus(
          String(scheduleId),
          Number(trendIndex),
          "failed"
        );
      }
    } catch {}
    // Update workflow history as failed if executionId is provided
    try {
      const { executionId } = req.body;
      if (executionId) {
        await WorkflowHistory.findOneAndUpdate(
          { executionId },
          {
            status: "failed",
            completedAt: new Date(),
            errorMessage: e.message || "Video download failed",
          }
        );
      }
    } catch (workflowError) {}

    // Send error notification if we have user info
    try {
      const { email } = req.body;
      if (email) {
        const user = await videoService.getUserByEmail(email);
        if (user) {
          notificationService.notifyVideoDownloadProgress(
            user._id.toString(),
            "error",
            "error",
            {
              message: "Failed to download video. Please try again.",
              error: e.message || "Unknown error occurred",
            }
          );
        }
      }
    } catch (notificationError) {}

    return res
      .status(500)
      .json({ success: false, message: e.message || "Internal server error" });
  }
}

/**
 * Update video status
 * POST /api/video/status
 */
export async function updateStatus(req: Request, res: Response) {
  try {
    const validationResult = validateUpdateVideoStatus(req.body);
    if (!validationResult.success) {
      return res.status(400).json({
        success: false,
        message: "Validation failed",
        errors: validationResult.errors,
      });
    }

    const { videoId, status, metadata } = validationResult.data!;

    const updatedVideo = await videoService.updateVideoStatus(
      String(videoId),
      status as "processing" | "ready" | "failed"
    );

    if (!updatedVideo) {
      return res.status(404).json({
        success: false,
        message: "Video not found",
      });
    }

    // Update metadata if provided
    if (metadata) {
      await videoService.updateVideoMetadata(String(videoId), metadata);
    }

    return res.json({
      success: true,
      message: "Video status updated successfully",
      data: {
        videoId: updatedVideo.videoId,
        status: updatedVideo.status,
        updatedAt: updatedVideo.updatedAt,
      },
    });
  } catch (e: any) {
    return res
      .status(500)
      .json({ success: false, message: e.message || "Internal server error" });
  }
}

/**
 * Download video proxy (server-side download to avoid CORS)
 * GET /api/video/download-proxy
 */
export async function downloadProxy(req: Request, res: Response) {
  try {
    const validationResult = validateDownloadProxyQuery(req.query);
    if (!validationResult.success) {
      return res.status(400).json({
        success: false,
        message: "Validation failed",
        errors: validationResult.errors,
      });
    }

    const { url: videoUrl } = validationResult.data!;

    // Get token from query parameter or Authorization header
    const token = extractToken(req);

    if (!token) {
      return res.status(401).json({
        success: false,
        message:
          "Access token is required (provide via ?token=xxx or Authorization header)",
      });
    }

    // Validate token
    try {
      const user = await getCurrentUser(req);
      if (!user) {
        return res.status(401).json({
          success: false,
          message: "User not found",
        });
      }
    } catch (authError: any) {
      return res.status(401).json({
        success: false,
        message: authError.message || "Invalid or expired access token",
      });
    }

    // Fetch the video from S3 (server-side, no CORS issues)
    const videoResponse = await fetch(videoUrl);

    if (!videoResponse.ok) {
      throw new Error(`Failed to fetch video: ${videoResponse.status}`);
    }

    // Get video data
    const videoBuffer = await videoResponse.arrayBuffer();
    const contentType =
      videoResponse.headers.get("content-type") || "video/mp4";

    // Return the video as a downloadable file
    res.setHeader("Content-Type", contentType);
    res.setHeader("Content-Disposition", 'attachment; filename="video.mp4"');
    res.setHeader("Content-Length", videoBuffer.byteLength.toString());
    res.setHeader("Cache-Control", "no-cache");
    res.setHeader("Access-Control-Allow-Origin", "*");
    res.setHeader("Access-Control-Allow-Methods", "*");
    res.setHeader("Access-Control-Allow-Headers", "*");

    return res.status(200).send(Buffer.from(videoBuffer));
  } catch (e: any) {
    return res
      .status(500)
      .json({ success: false, message: e.message || "Internal server error" });
  }
}

