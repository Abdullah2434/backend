import { Request, Response } from "express";
import AuthService from "../../../services/auth.service";
import VideoService from "../services/video.service";
import VideoSchedule from "../../../models/VideoSchedule";
import VideoScheduleService from "../../../services/videoSchedule.service";
import { AutoSocialPostingService } from "../../../services/autoSocialPosting.service";
import DefaultAvatar from "../../../models/avatar";
import DefaultVoice from "../../../models/voice";
import WorkflowHistory from "../../../models/WorkflowHistory";
import { photoAvatarQueue } from "../../../queues/photoAvatarQueue";
import { notificationService } from "../../../services/notification.service";
import multer from "multer";
import https from "https";
import url from "url";
import User from "../../../models/User";
import mongoose from "mongoose";
import { SubscriptionService } from "../../../services/subscription.service";
import { EmailService } from "../../../services/email";
import PendingCaptions from "../../../models/PendingCaptions";
import CaptionGenerationService from "../../../services/captionGeneration.service";

const authService = new AuthService();
const videoService = new VideoService();
const upload = multer({ dest: "/tmp" });

function requireAuth(req: Request) {
  const token = (req.headers.authorization || "").replace("Bearer ", "");
  if (!token) throw new Error("Access token is required");
  const payload = authService.verifyToken(token);
  if (!payload) throw new Error("Invalid or expired access token");
  return payload;
}

export async function gallery(req: Request, res: Response) {
  try {
    const payload = requireAuth(req);
    const user = await authService.getCurrentUser(
      req.headers.authorization?.replace("Bearer ", "") || ""
    );
    if (!user) {
      return res
        .status(401)
        .json({ success: false, message: "Invalid or expired access token" });
    }

    const videosWithUrls = await videoService.getUserVideosWithDownloadUrls(
      user._id.toString()
    );
    const stats = await videoService.getUserVideoStats(user._id.toString());

    const formattedVideos = videosWithUrls.map((video: any) => ({
      id: video._id.toString(),
      videoId: video.videoId,
      title: video.title,
      status: video.status,
      autoGenerated: Boolean(video.autoGenerated),
      createdAt: video.createdAt,
      updatedAt: video.updatedAt,
      metadata: video.metadata,
      downloadUrl: video.downloadUrl || null,
      videoUrl: video.videoUrl || null,
      socialMediaCaptions: video.socialMediaCaptions || null,
    }));

    return res.json({
      success: true,
      message: "Video gallery retrieved successfully",
      data: {
        videos: formattedVideos,
        totalCount: stats.totalCount,
        readyCount: stats.readyCount,
        processingCount: stats.processingCount,
        failedCount: stats.failedCount,
      },
    });
  } catch (e: any) {
    const status = e.message.includes("Access token") ? 401 : 500;
    return res
      .status(status)
      .json({ success: false, message: e.message || "Internal server error" });
  }
}

export async function trackExecution(req: Request, res: Response) {
  try {
    const { executionId, email } = req.body;

    // Validate required fields
    if (!executionId || !email) {
      return res.status(400).json({
        success: false,
        message: "Missing required fields: executionId, email",
      });
    }

    // Find user by email
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(404).json({
        success: false,
        message: "User not found",
      });
    }

    // Create workflow history entry
    const workflowHistory = new WorkflowHistory({
      executionId,
      userId: user._id,
      email,
    });

    await workflowHistory.save();

    console.log(`Execution tracked: ${executionId} for user: ${email}`);

    return res.json({
      success: true,
      message: "Execution tracked successfully",
      data: {
        executionId,
        userId: user._id,
        email,
        timestamp: new Date().toISOString(),
      },
    });
  } catch (e: any) {
    console.error("Error tracking execution:", e);
    return res.status(500).json({
      success: false,
      message: e.message || "Internal server error",
    });
  }
}

export async function checkPendingWorkflows(req: Request, res: Response) {
  try {
    const { userId } = req.params;

    // Validate required fields
    if (!userId) {
      return res.status(400).json({
        success: false,
        message: "Missing required parameter: userId",
      });
    }

    // Validate userId format (should be a valid ObjectId string)
    if (!mongoose.Types.ObjectId.isValid(userId)) {
      return res.status(400).json({
        success: false,
        message: "Invalid userId format",
      });
    }

    // Convert string userId to ObjectId for database query
    const userObjectId = new mongoose.Types.ObjectId(userId);

    // Find all pending workflows for this user
    const pendingWorkflows = await WorkflowHistory.find({
      userId: userObjectId,
      status: "pending",
    });

    console.log(`🔍 Checking pending workflows for user: ${userId}`);
    console.log(`📋 Found ${pendingWorkflows.length} pending workflows`);

    if (pendingWorkflows.length === 0) {
      return res.json({
        success: true,
        message: "No pending workflows found",
        data: {
          hasPendingWorkflows: false,
          pendingCount: 0,
          message: null,
        },
      });
    }

    // Send socket notification for each pending workflow
    for (const workflow of pendingWorkflows) {
      try {
        notificationService.notifyUser(userId, "video-download-update", {
          type: "progress",
          status: "processing",
          message: "Your video creation is in progress",
          timestamp: new Date().toISOString(),
        });

        console.log(
          `📤 Sent pending workflow notification for execution ${workflow.executionId}`
        );
      } catch (notificationError) {
        console.error(
          `❌ Error sending notification for workflow ${workflow.executionId}:`,
          notificationError
        );
      }
    }

    // Return pending workflow information
    return res.json({
      success: true,
      message: "Pending workflows found",
      data: {
        hasPendingWorkflows: true,
        pendingCount: pendingWorkflows.length,
        message: "Your video creation is in progress",
        workflows: pendingWorkflows.map((workflow) => ({
          executionId: workflow.executionId,
          createdAt: workflow.createdAt,
          email: workflow.email,
        })),
      },
    });
  } catch (e: any) {
    console.error("Error checking pending workflows:", e);
    return res.status(500).json({
      success: false,
      message: e.message || "Internal server error",
    });
  }
}

export async function download(req: Request, res: Response) {
  try {
    const { videoUrl, email, title, executionId, scheduleId, trendIndex } =
      req.body;

    // Validate required fields
    const requiredFields = ["videoUrl", "email", "title"];
    for (const field of requiredFields) {
      if (!req.body[field] || String(req.body[field]).trim() === "") {
        return res.status(400).json({
          success: false,
          message: `Missing required field: ${field}`,
        });
      }
    }

    // Get user ID for notifications
    const user = await videoService.getUserByEmail(email);
    if (!user) {
      return res.status(404).json({
        success: false,
        message: "User not found",
      });
    }

    // Send initial notification
    notificationService.notifyVideoDownloadProgress(
      user._id.toString(),
      "download",
      "progress",
      {
        message: "Starting video download...",
      }
    );

    const result = await videoService.downloadAndUploadVideo(
      videoUrl,
      email,
      title
    );

    // Mark whether this video was auto-generated (scheduled) or manual
    try {
      await videoService.updateVideoAutoGenerated(
        result.videoId,
        Boolean(scheduleId)
      );
    } catch (autoGenErr) {
      console.warn("Warning updating autoGenerated flag:", autoGenErr);
    }

    // If captions are provided in the request (manual/custom flow), store them on the video
    try {
      const captions = (req.body as any)?.captions;
      if (captions && typeof captions === "object") {
        await videoService.updateVideoCaptions(result.videoId, {
          instagram_caption: captions.instagram_caption,
          facebook_caption: captions.facebook_caption,
          linkedin_caption: captions.linkedin_caption,
          twitter_caption: captions.twitter_caption,
          tiktok_caption: captions.tiktok_caption,
        });
        console.log("📑 Stored provided captions on video", result.videoId);
      } else {
        // Otherwise, try to consume server-stored pending captions (generated at createVideo)
        try {
          const pending = await PendingCaptions.findOne({ email, title });
          if (pending?.captions) {
            await videoService.updateVideoCaptions(result.videoId, {
              instagram_caption: pending.captions.instagram_caption,
              facebook_caption: pending.captions.facebook_caption,
              linkedin_caption: pending.captions.linkedin_caption,
              twitter_caption: pending.captions.twitter_caption,
              tiktok_caption: pending.captions.tiktok_caption,
            });
            console.log("📑 Stored pending captions on video", result.videoId);
            // best-effort cleanup
            try {
              await PendingCaptions.deleteOne({ _id: (pending as any)._id });
            } catch {}
          }
        } catch (consumeErr) {
          console.warn(
            "No pending captions found or failed to consume:",
            consumeErr
          );
        }
      }
    } catch (capErr) {
      console.warn("Warning storing captions:", capErr);
    }

    // Update workflow history if executionId is provided
    if (executionId) {
      try {
        await WorkflowHistory.findOneAndUpdate(
          { executionId },
          {
            status: "completed",
            completedAt: new Date(),
          }
        );
        console.log(
          `Workflow history updated for execution ${executionId}: completed`
        );
      } catch (workflowError) {
        console.error(
          `Error updating workflow history for execution ${executionId}:`,
          workflowError
        );
      }
    }

    // Send success notification
    notificationService.notifyVideoDownloadProgress(
      user._id.toString(),
      "complete",
      "success",
      {
        message: "Video downloaded and uploaded successfully!",
        videoId: result.videoId,
        title: result.title,
        size: result.size,
      }
    );

    // If schedule context is provided, mark schedule item completed and trigger auto-posting
    if (scheduleId && (trendIndex === 0 || Number.isInteger(trendIndex))) {
      // Run asynchronously; do not delay the response
      (async () => {
        try {
          console.log(
            `🗓️ Download completed with schedule context. scheduleId=${scheduleId}, trendIndex=${trendIndex}`
          );

          // Idempotency: if already completed, skip posting
          const schedule = await VideoSchedule.findById(scheduleId);
          if (!schedule) {
            console.warn(`⚠️ Schedule not found for scheduleId=${scheduleId}`);
            return;
          }

          const trend = schedule.generatedTrends?.[Number(trendIndex)];
          if (!trend) {
            console.warn(
              `⚠️ Trend not found at index ${trendIndex} for schedule ${scheduleId}`
            );
            return;
          }

          if (trend.status === "completed" && trend.videoId) {
            console.log(
              `ℹ️ Schedule trend already completed with videoId=${trend.videoId}. Skipping auto-post.`
            );
            return;
          }

          // Update schedule status to completed and set videoId
          const videoScheduleService = new VideoScheduleService();
          await videoScheduleService.updateVideoStatus(
            String(scheduleId),
            Number(trendIndex),
            "completed",
            result.videoId
          );

          // Prefer a signed S3 download URL if available
          const readyVideo = await videoService.getVideoWithDownloadUrl(
            result.videoId
          );
          const downloadableUrl = (readyVideo as any)?.downloadUrl || videoUrl;

          // Trigger auto social posting using existing manual code paths
          const autoPoster = new AutoSocialPostingService();
          await autoPoster.postVideoToSocialMedia({
            userId: user._id.toString(),
            scheduleId: String(scheduleId),
            trendIndex: Number(trendIndex),
            videoUrl: downloadableUrl,
            videoTitle: result.title,
          });

          console.log(
            `🚀 Auto social posting kicked off for schedule ${scheduleId}, trend ${trendIndex}`
          );
        } catch (autoErr: any) {
          console.error(
            "❌ Error during schedule completion/auto-post from download endpoint:",
            autoErr
          );
        }
      })();
    }

    return res.json({
      success: true,
      message: "Video downloaded and uploaded successfully",
      data: result,
    });
  } catch (e: any) {
    // If schedule context is present, mark schedule item as failed
    try {
      const { scheduleId, trendIndex } = req.body as any;
      if (scheduleId && (trendIndex === 0 || Number.isInteger(trendIndex))) {
        const videoScheduleService = new VideoScheduleService();
        await videoScheduleService.updateVideoStatus(
          String(scheduleId),
          Number(trendIndex),
          "failed"
        );
        console.warn(
          `📉 Marked schedule ${scheduleId} trend ${trendIndex} as failed due to download error`
        );
      }
    } catch {}
    // Update workflow history as failed if executionId is provided
    try {
      const { executionId } = req.body;
      if (executionId) {
        await WorkflowHistory.findOneAndUpdate(
          { executionId },
          {
            status: "failed",
            completedAt: new Date(),
            errorMessage: e.message || "Video download failed",
          }
        );
        console.log(
          `Workflow history updated for execution ${executionId}: failed`
        );
      }
    } catch (workflowError) {
      console.error(
        `Error updating workflow history for execution:`,
        workflowError
      );
    }

    // Send error notification if we have user info
    try {
      const { email } = req.body;
      if (email) {
        const user = await videoService.getUserByEmail(email);
        if (user) {
          notificationService.notifyVideoDownloadProgress(
            user._id.toString(),
            "error",
            "error",
            {
              message: "Failed to download video. Please try again.",
              error: e.message || "Unknown error occurred",
            }
          );
        }
      }
    } catch (notificationError) {
      console.error("Error sending notification:", notificationError);
    }

    return res
      .status(500)
      .json({ success: false, message: e.message || "Internal server error" });
  }
}

export async function updateStatus(req: Request, res: Response) {
  try {
    const { videoId, status, metadata } = req.body;

    if (!videoId || !status) {
      return res.status(400).json({
        success: false,
        message: "Video ID and status are required",
      });
    }

    if (!["processing", "ready", "failed"].includes(status)) {
      return res.status(400).json({
        success: false,
        message: "Invalid status. Must be processing, ready, or failed",
      });
    }

    const updatedVideo = await videoService.updateVideoStatus(videoId, status);

    if (!updatedVideo) {
      return res.status(404).json({
        success: false,
        message: "Video not found",
      });
    }

    // Update metadata if provided
    if (metadata) {
      await videoService.updateVideoMetadata(videoId, metadata);
    }

    return res.json({
      success: true,
      message: "Video status updated successfully",
      data: {
        videoId: updatedVideo.videoId,
        status: updatedVideo.status,
        updatedAt: updatedVideo.updatedAt,
      },
    });
  } catch (e: any) {
    return res
      .status(500)
      .json({ success: false, message: e.message || "Internal server error" });
  }
}

export async function deleteVideo(req: Request, res: Response) {
  try {
    const payload = requireAuth(req);
    const { videoId } = req.body;

    if (!videoId) {
      return res.status(400).json({
        success: false,
        message: "Video ID is required",
      });
    }

    const video = await videoService.getVideo(videoId);
    if (!video) {
      return res.status(404).json({
        success: false,
        message: "Video not found",
      });
    }

    // Verify video belongs to user
    if (video.userId && video.userId.toString() !== payload.userId) {
      return res.status(403).json({
        success: false,
        message: "Unauthorized to delete this video",
      });
    }

    const deleted = await videoService.deleteVideo(videoId);

    if (!deleted) {
      return res.status(500).json({
        success: false,
        message: "Failed to delete video",
      });
    }

    return res.json({
      success: true,
      message: "Video deleted successfully",
    });
  } catch (e: any) {
    const status = e.message.includes("Access token") ? 401 : 500;
    return res
      .status(status)
      .json({ success: false, message: e.message || "Internal server error" });
  }
}

export async function downloadProxy(req: Request, res: Response) {
  try {
    const videoUrl = String(req.query.url || "");
    if (!videoUrl) {
      return res.status(400).json({
        success: false,
        message: "Video URL is required",
      });
    }

    console.log("Proxying video download from:", videoUrl);

    // Fetch the video from S3 (server-side, no CORS issues)
    const videoResponse = await fetch(videoUrl);

    if (!videoResponse.ok) {
      throw new Error(`Failed to fetch video: ${videoResponse.status}`);
    }

    // Get video data
    const videoBuffer = await videoResponse.arrayBuffer();
    const contentType =
      videoResponse.headers.get("content-type") || "video/mp4";

    // Return the video as a downloadable file
    res.setHeader("Content-Type", contentType);
    res.setHeader("Content-Disposition", 'attachment; filename="video.mp4"');
    res.setHeader("Content-Length", videoBuffer.byteLength.toString());
    res.setHeader("Cache-Control", "no-cache");
    res.setHeader("Access-Control-Allow-Origin", "*");
    res.setHeader("Access-Control-Allow-Methods", "*");
    res.setHeader("Access-Control-Allow-Headers", "*");

    return res.status(200).send(Buffer.from(videoBuffer));
  } catch (e: any) {
    return res
      .status(500)
      .json({ success: false, message: e.message || "Internal server error" });
  }
}

export async function getAvatars(req: Request, res: Response) {
  try {
    const user = await authService.getCurrentUser(
      req.headers.authorization?.replace("Bearer ", "") || ""
    );
    if (!user) {
      return res
        .status(401)
        .json({ success: false, message: "Invalid or expired access token" });
    }
    const userObjectId = user._id;
    // Fetch custom avatars for user
    const customAvatars = await DefaultAvatar.find({ userId: userObjectId });
    // Fetch default avatars (no userId)
    const defaultAvatars = await DefaultAvatar.find({
      userId: { $exists: false },
      default: true,
    });
    return res.json({
      success: true,
      custom: customAvatars,
      default: defaultAvatars,
    });
  } catch (e: any) {
    return res
      .status(500)
      .json({ success: false, message: e.message || "Internal server error" });
  }
}

export async function getVoices(req: Request, res: Response) {
  try {
    const user = await authService.getCurrentUser(
      req.headers.authorization?.replace("Bearer ", "") || ""
    );
    if (!user) {
      return res
        .status(401)
        .json({ success: false, message: "Invalid or expired access token" });
    }
    const userObjectId = user._id;
    // Fetch custom voices for user
    const customVoices = await DefaultVoice.find({ userId: userObjectId });
    // Fetch default voices (no userId)
    const defaultVoices = await DefaultVoice.find({
      userId: { $exists: false },
      default: true,
    });
    return res.json({
      success: true,
      custom: customVoices,
      default: defaultVoices,
    });
  } catch (e: any) {
    return res
      .status(500)
      .json({ success: false, message: e.message || "Internal server error" });
  }
}

export const createPhotoAvatarUpload = upload.single("image");

export async function createPhotoAvatar(
  req: Request & { file?: Express.Multer.File },
  res: Response
) {
  try {
    const { age_group, name, gender, userId, ethnicity } = req.body;
    if (!req.file || !age_group || !name || !gender || !userId) {
      return res
        .status(400)
        .json({ success: false, message: "Missing required fields" });
    }
    // Use uploaded file path
    const tempImagePath = req.file.path;
    // Add job to BullMQ queue
    await photoAvatarQueue.add("create-photo-avatar", {
      imagePath: tempImagePath,
      age_group,
      name,
      gender,
      userId,
      ethnicity,
      mimeType: req.file.mimetype, // Pass the correct MIME type
    });
    return res.json({
      success: true,
      message:
        "Photo avatar creation started. You will be notified when ready.",
    });
  } catch (e: any) {
    return res
      .status(500)
      .json({ success: false, message: e.message || "Internal server error" });
  }
}

export async function createVideo(req: Request, res: Response) {
  try {
    const requiredFields = [
      "prompt",
      "avatar",
      "name",
      "position",
      "companyName",
      "license",
      "tailoredFit",
      "socialHandles",
      "videoTopic",
      "topicKeyPoints",
      "city",
      "preferredTone",
      "callToAction",
      "email",
    ];
    for (const field of requiredFields) {
      if (!req.body[field] || String(req.body[field]).trim() === "") {
        return res.status(400).json({
          success: false,
          message: `${field} is required`,
        });
      }
    }
    const webhookUrl = process.env.VIDEO_CREATION_WEBHOOK_URL;
    if (!webhookUrl) {
      console.error(
        "VIDEO_CREATION_WEBHOOK_URL environment variable is not set"
      );
      return res.status(500).json({
        success: false,
        message: "Video creation service is not configured",
      });
    }

    // Preflight subscription check (stop before webhook)
    try {
      const email = String(req.body.email || "").trim();
      if (!email) {
        return res
          .status(400)
          .json({ success: false, message: "Email is required" });
      }
      const user = await videoService.getUserByEmail(email);
      if (!user) {
        return res
          .status(404)
          .json({ success: false, message: "User not found" });
      }
      const subscriptionService = new SubscriptionService();
      const videoLimit = await subscriptionService.canCreateVideo(
        user._id.toString()
      );
      if (!videoLimit.canCreate) {
        // Send plan-full email notification
        try {
          const emailService = new EmailService();
          await emailService.send(
            email,
            "Your monthly video limit has been reached",
            `
            <h2>Plan Limit Reached</h2>
            <p>You have reached your monthly video limit (${
              videoLimit.limit
            }).</p>
            <p>Please upgrade your plan to continue creating videos.</p>
            <p><a href="${
              process.env.FRONTEND_URL || "https://www.edgeairealty.com"
            }/pricing" target="_blank">Upgrade Plan</a></p>
            `
          );
        } catch (mailErr) {
          console.warn("Failed to send plan limit email:", mailErr);
        }
        return res.status(429).json({
          success: false,
          message: `Video limit reached. Your plan allows ${videoLimit.limit} videos per month. Please upgrade your subscription to create more videos.`,
        });
      }
    } catch (subErr) {
      console.error("Subscription preflight check failed:", subErr);
      return res
        .status(500)
        .json({ success: false, message: "Subscription check failed" });
    }
    const body = req.body;
    const webhookData = {
      prompt: body.prompt,
      avatar: body.avatar,
      name: body.name,
      position: body.position,
      companyName: body.companyName,
      license: body.license,
      tailoredFit: body.tailoredFit,
      socialHandles: body.socialHandles,
      videoTopic: body.videoTopic,
      topicKeyPoints: body.topicKeyPoints,
      city: body.city,
      preferredTone: body.preferredTone,
      zipCode: 90014,
      zipKeyPoints: "new bars and restaurants",
      callToAction: body.callToAction,
      email: body.email,
      timestamp: new Date().toISOString(),
      requestId: `video_${Date.now()}_${Math.random()
        .toString(36)
        .substr(2, 9)}`,
    };

    // Generate and store captions for manual/custom on the basis of topic/key points (do not send to N8N)
    try {
      const topic = String(body.videoTopic || body.name || "").trim();
      const keyPoints = String(body.topicKeyPoints || body.prompt || "").trim();
      if (topic && keyPoints) {
        const captions = await CaptionGenerationService.generateCaptions(
          topic,
          keyPoints,
          {
            name: body.name,
            position: body.position,
            companyName: body.companyName,
            city: body.city,
            socialHandles: body.socialHandles,
          }
        );
        await PendingCaptions.findOneAndUpdate(
          { email: body.email, title: body.videoTopic || body.title || topic },
          {
            email: body.email,
            title: body.videoTopic || body.title || topic,
            captions,
          },
          { upsert: true, new: true }
        );
        console.log(
          "📝 Generated and stored pending captions for manual video"
        );
      }
    } catch (capGenErr) {
      console.warn(
        "Caption generation (manual) failed, continuing:",
        capGenErr
      );
    }
    // Use native node http(s) for webhook POST
    const https = require("https");
    const url = require("url");
    const parsedUrl = url.parse(webhookUrl);
    const postData = JSON.stringify(webhookData);
    const options = {
      hostname: parsedUrl.hostname,
      path: parsedUrl.path,
      port: parsedUrl.port || 443,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Content-Length": Buffer.byteLength(postData),
      },
    };
    const webhookReq = https.request(options, (webhookRes: any) => {
      let data = "";
      webhookRes.on("data", (chunk: any) => {
        data += chunk;
      });
      webhookRes.on("end", () => {
        let webhookResult;
        try {
          webhookResult = JSON.parse(data);
        } catch {
          webhookResult = data;
        }
        if (webhookRes.statusCode < 200 || webhookRes.statusCode >= 300) {
          return res.status(502).json({
            success: false,
            message: "Failed to create video. Please try again later.",
            error: `Webhook error: ${webhookRes.statusCode}`,
          });
        }
        return res.status(200).json({
          success: true,
          message: "Video creation request submitted successfully",
          data: {
            requestId: webhookData.requestId,
            webhookResponse: webhookResult,
            timestamp: webhookData.timestamp,
            status: "pending",
          },
        });
      });
    });
    webhookReq.on("error", (error: any) => {
      console.error("Create video API Error:", error);
      return res.status(500).json({
        success: false,
        message: "Internal server error. Please try again later.",
        error: error.message || error,
      });
    });
    webhookReq.write(postData);
    webhookReq.end();
  } catch (error: any) {
    console.error("Create video API Error:", error);
    return res.status(500).json({
      success: false,
      message: "Internal server error. Please try again later.",
      error: error.message,
    });
  }
}

export async function generateVideo(req: Request, res: Response) {
  try {
    const body = req.body;
    const requiredFields = [
      "hook",
      "body",
      "conclusion",
      "company_name",
      "social_handles",
      "license",
      "avatar_title",
      "avatar_body",
      "avatar_conclusion",
      "email",
      "title",
    ];
    for (const field of requiredFields) {
      console.log(`Checking field ${field}:`, body[field]);
      if (!body[field] || String(body[field]).trim() === "") {
        console.log(`Field ${field} is missing or empty`);
        return res.status(400).json({
          success: false,
          message: `Missing or empty required field: ${field}`,
          error: `Field ${field} is required and cannot be empty`,
          receivedData: body,
        });
      }
    }
    const webhookUrl = process.env.GENERATE_VIDEO_WEBHOOK_URL;
    if (!webhookUrl) {
      return res.status(500).json({
        success: false,
        message: "GENERATE_VIDEO_WEBHOOK_URL environment variable is not set",
      });
    }

    // Preflight subscription check (stop before webhook)
    try {
      const email = String(body.email || "").trim();
      if (!email) {
        return res
          .status(400)
          .json({ success: false, message: "Email is required" });
      }
      const user = await videoService.getUserByEmail(email);
      if (!user) {
        return res
          .status(404)
          .json({ success: false, message: "User not found" });
      }
      const subscriptionService = new SubscriptionService();
      const videoLimit = await subscriptionService.canCreateVideo(
        user._id.toString()
      );
      if (!videoLimit.canCreate) {
        // Send plan-full email notification
        try {
          const emailService = new EmailService();
          await emailService.send(
            email,
            "Your monthly video limit has been reached",
            `
            <h2>Plan Limit Reached</h2>
            <p>You have reached your monthly video limit (${
              videoLimit.limit
            }).</p>
            <p>Please upgrade your plan to continue creating videos.</p>
            <p><a href="${
              process.env.FRONTEND_URL || "https://www.edgeairealty.com"
            }/pricing" target="_blank">Upgrade Plan</a></p>
            `
          );
        } catch (mailErr) {
          console.warn("Failed to send plan limit email:", mailErr);
        }
        return res.status(429).json({
          success: false,
          message: `Video limit reached. Your plan allows ${videoLimit.limit} videos per month. Please upgrade your subscription to create more videos.`,
        });
      }
    } catch (subErr) {
      console.error("Subscription preflight check failed:", subErr);
      return res
        .status(500)
        .json({ success: false, message: "Subscription check failed" });
    }
    // Get gender from DefaultAvatar
    const avatarDoc = await DefaultAvatar.findOne({
      avatar_id: body.avatar_title,
    });
    console.log("Found avatar document:", avatarDoc);
    const gender = avatarDoc ? avatarDoc.gender : undefined;
    // Get voice_id from DefaultVoice by gender
    let voice_id: string | undefined = undefined;
    if (gender) {
      const voiceDoc = await DefaultVoice.findOne({ gender });
      console.log("Found voice document:", voiceDoc);
      voice_id = voiceDoc ? voiceDoc.voice_id : undefined;
    }
    console.log("Using voice_id:", voice_id);
    console.log(body.body, "body body");

    // Generate dynamic social media captions using our intelligent system
    console.log(
      "🎨 Generating dynamic social media captions for custom video..."
    );
    const DynamicCaptionGenerationService =
      require("../../services/dynamicCaptionGeneration.service").default;
    const captions =
      await DynamicCaptionGenerationService.generateCustomVideoCaptions(
        body.hook,
        body.body,
        body.conclusion,
        req.user?._id || "anonymous", // Use authenticated user ID
        {
          name: body.company_name, // Using company name as context
          position: "Real Estate Professional",
          companyName: body.company_name,
          city: "Your City", // Could be extracted from user settings
          socialHandles: body.social_handles,
        }
      );
    console.log("✅ Captions generated successfully");

    const webhookData = {
      hook: body.hook,
      body: body.body,
      conclusion: body.conclusion,
      company_name: body.company_name,
      social_handles: body.social_handles,
      license: body.license,
      avatar_body: body.avatar_body,
      avatar_conclusion: body.avatar_conclusion,
      avatar_title: body.avatar_title,
      email: body.email,
      title: body.title,
      voice: voice_id,
      isDefault: avatarDoc?.default,
      timestamp: new Date().toISOString(),
      // Optional schedule context for auto runs (forward to N8N)
      ...(body.scheduleId ? { scheduleId: body.scheduleId } : {}),
      ...(body.trendIndex !== undefined
        ? { trendIndex: Number(body.trendIndex) }
        : {}),
      ...(body.scheduleId !== undefined || body.trendIndex !== undefined
        ? { isScheduled: true }
        : {}),
      // Store captions for later retrieval (not sent to webhook)
      _captions: captions,
    };
    // Remove captions from webhook data (captions are stored separately)
    const { _captions, ...webhookPayload } = webhookData;

    // Log schedule context if present
    if (
      webhookPayload.scheduleId !== undefined ||
      webhookPayload.trendIndex !== undefined
    ) {
      console.log(
        `📦 Forwarding schedule context to N8N: scheduleId=${webhookPayload.scheduleId}, trendIndex=${webhookPayload.trendIndex}`
      );
    } else {
      console.log(
        "📦 No schedule context provided for this generation request"
      );
    }

    // Fire and forget: send request to n8n webhook and return immediately
    const https = require("https");
    const url = require("url");
    const parsedUrl = url.parse(webhookUrl);
    const postData = JSON.stringify(webhookPayload);
    const options = {
      hostname: parsedUrl.hostname,
      path: parsedUrl.path,
      port: parsedUrl.port || 443,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Content-Length": Buffer.byteLength(postData),
      },
    };
    const webhookReq = https.request(options, (webhookRes: any) => {
      webhookRes.on("data", () => {}); // ignore data
      webhookRes.on("end", () => {
        console.log(
          "N8n webhook request sent successfully, status:",
          webhookRes.statusCode
        );
      });
    });
    webhookReq.on("error", (error: any) => {
      console.error("N8n webhook request failed:", error);
    });
    webhookReq.write(postData);
    webhookReq.end();
    // Return immediately with request info
    const response = {
      success: true,
      message: "Video generation started successfully",
      data: {
        status: "processing",
        timestamp: new Date().toISOString(),
        estimated_completion: new Date(
          Date.now() + 15 * 60 * 1000
        ).toISOString(),
        note: "Video generation is running in the background. The video will be available when ready.",
      },
    };
    console.log("Returning response:", response);
    return res.json(response);
  } catch (error: any) {
    console.error("Error in video generation API:", error);
    return res.status(500).json({
      success: false,
      message: "Internal server error. Please try again later.",
      error: error.message || "Unknown error occurred",
    });
  }
}

// Topic-related controllers
export async function getAllTopics(req: Request, res: Response) {
  try {
    const topics = await videoService.getAllTopics();

    return res.json({
      success: true,
      message: "Topics retrieved successfully",
      data: topics,
    });
  } catch (e: any) {
    return res.status(500).json({
      success: false,
      message: e.message || "Internal server error",
    });
  }
}

export async function getTopicByType(req: Request, res: Response) {
  try {
    const { topic } = req.params;

    if (!topic) {
      return res.status(400).json({
        success: false,
        message: "Topic parameter is required",
      });
    }

    const topicData = await videoService.getTopicByType(topic);

    if (!topicData) {
      return res.status(404).json({
        success: false,
        message: "Topic not found",
      });
    }

    return res.json({
      success: true,
      message: "Topic retrieved successfully",
      data: topicData,
    });
  } catch (e: any) {
    return res.status(500).json({
      success: false,
      message: e.message || "Internal server error",
    });
  }
}

export async function getTopicById(req: Request, res: Response) {
  try {
    const { id } = req.params;

    if (!id) {
      return res.status(400).json({
        success: false,
        message: "ID parameter is required",
      });
    }

    const topicData = await videoService.getTopicById(id);

    if (!topicData) {
      return res.status(404).json({
        success: false,
        message: "Topic not found",
      });
    }

    return res.json({
      success: true,
      message: "Topic retrieved successfully",
      data: topicData,
    });
  } catch (e: any) {
    return res.status(500).json({
      success: false,
      message: e.message || "Internal server error",
    });
  }
}
