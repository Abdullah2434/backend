import { Request, Response } from "express";
import AuthService from "../services/auth.service";
import { VideoService } from "../services/video";
import DefaultAvatar from "../models/avatar";
import DefaultVoice from "../models/voice";
import WorkflowHistory from "../models/WorkflowHistory";
import { photoAvatarQueue } from "../queues/photoAvatarQueue";
import { UserVideoSettingsService } from "../services/user";
import multer from "multer";
import User from "../models/User";
import { notificationService } from "../services/notification.service";
import mongoose from "mongoose";
import { SubscriptionService } from "../services/payment";
import PendingCaptions from "../models/PendingCaptions";
import {
  updateVideoNoteSchema,
  videoIdParamSchema,
} from "../validations/video.validations";
import {
  extractAccessToken,
  formatValidationErrors,
  handleControllerError,
} from "../utils/controllerHelpers";
import {
  sendWebhookRequest,
  sendFireAndForgetWebhook,
  getLanguageCode,
  getVoiceEnergyParams,
  getVoiceIdFromAvatar,
  resolveAvatarTypes,
  convertVideoCaptionToBoolean,
  normalizeVideoCaptionForStorage,
  storePendingCaptionsForDynamicGeneration,
  storeFallbackCaptions,
  formatSocialMediaCaptions,
  validateRequiredFields,
  generateRequestId,
  updateVideoAutoGeneratedFlag,
  handleVideoCaptions,
  updateWorkflowHistoryStatus,
  handleScheduleAutoPosting,
  markScheduleAsFailed,
  sendErrorNotification,
  checkVideoCreationLimit,
} from "../utils/videoControllerHelpers";
import {
  VALID_VIDEO_STATUSES,
  DEFAULT_LANGUAGE,
  DEFAULT_VIDEO_CONTENT_TYPE,
  ESTIMATED_COMPLETION_MINUTES,
  ERROR_MESSAGES,
  SOCIAL_MEDIA_PLATFORMS,
} from "../constants/video.constants";

// ==================== SERVICE INSTANCES ====================
const authService = new AuthService();
const videoService = new VideoService();
const upload = multer({ dest: "/tmp" });

// ==================== HELPER FUNCTIONS ====================
/**
 * Require authentication and return payload
 */
function requireAuth(req: Request) {
  const token = extractAccessToken(req);
  if (!token) {
    throw new Error(ERROR_MESSAGES.ACCESS_TOKEN_REQUIRED);
  }
  const payload = authService.verifyToken(token);
  if (!payload) {
    throw new Error(ERROR_MESSAGES.INVALID_ACCESS_TOKEN);
  }
  return payload;
}

export async function gallery(req: Request, res: Response): Promise<Response> {
  try {
    const payload = requireAuth(req);
    const token = extractAccessToken(req) || "";
    const user = await authService.getCurrentUser(token);
    if (!user) {
      return res.status(401).json({
        success: false,
        message: ERROR_MESSAGES.INVALID_ACCESS_TOKEN,
      });
    }

    // Extract and validate query parameters
    const page = Math.max(1, parseInt(String(req.query.page || "1"), 10)) || 1;
    const limit = Math.min(
      100,
      Math.max(1, parseInt(String(req.query.limit || "6"), 10)) || 6
    );
    const sortParam = String(req.query.sort || "newest").toLowerCase();
    const sort: "oldest" | "newest" | "all" =
      sortParam === "oldest" || sortParam === "newest" || sortParam === "all"
        ? sortParam
        : "newest";
    const search = req.query.search ? String(req.query.search).trim() : undefined;
    
    // Extract and validate videoType (optional - if not provided, return all videos)
    let videoType: string | undefined = undefined;
    if (req.query.videoType) {
      const videoTypeParam = String(req.query.videoType).trim();
      const validVideoTypes = ["talkingHead", "listingVideo", "tourVideo", "animatedVideo"];
      if (validVideoTypes.includes(videoTypeParam)) {
        videoType = videoTypeParam;
      }
    }

    // Get paginated videos
    const { videos: videosWithUrls, total } =
      await videoService.getUserVideosWithDownloadUrlsPaginated(
        user._id.toString(),
        page,
        limit,
        sort,
        search,
        videoType
      );

    // Get stats (calculated from all user videos, not filtered)
    const stats = await videoService.getUserVideoStats(user._id.toString());

    const formattedVideos = videosWithUrls.map((video: any) => {
      const socialMediaCaptions = formatSocialMediaCaptions(
        video.socialMediaCaptions
      );

      return {
        id: video._id.toString(),
        videoId: video.videoId,
        title: video.title,
        status: video.status,
        autoGenerated: Boolean(video.autoGenerated),
        createdAt: video.createdAt,
        updatedAt: video.updatedAt,
        metadata: video.metadata,
        downloadUrl: video.downloadUrl || null,
        videoUrl: video.videoUrl || null,
        socialMediaCaptions: video.socialMediaCaptions
          ? socialMediaCaptions
          : null,
        note: video.note || null,
        videoType: video.videoType || "talkingHead",
      };
    });

    // Calculate total pages
    const totalPages = Math.ceil(total / limit);

    return res.json({
      success: true,
      message: "Video gallery retrieved successfully",
      data: {
        videos: formattedVideos,
        pagination: {
          page,
          limit,
          total,
          totalPages,
        },
        stats: {
          totalCount: stats.totalCount,
          readyCount: stats.readyCount,
          processingCount: stats.processingCount,
          failedCount: stats.failedCount,
        },
      },
    });
  } catch (error) {
    return handleControllerError(
      error,
      res,
      "gallery",
      ERROR_MESSAGES.INTERNAL_SERVER_ERROR
    );
  }
}

export async function trackExecution(
  req: Request,
  res: Response
): Promise<Response> {
  try {
    const { executionId, email } = req.body;

    // Validate required fields
    const validation = validateRequiredFields(req.body, [
      "executionId",
      "email",
    ]);
    if (!validation.isValid) {
      return res.status(400).json({
        success: false,
        message: `Missing required field: ${validation.missingField}`,
      });
    }

    // Find user by email
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(404).json({
        success: false,
        message: ERROR_MESSAGES.USER_NOT_FOUND,
      });
    }

    // Create workflow history entry
    const workflowHistory = new WorkflowHistory({
      executionId,
      userId: user._id,
      email,
    });

    await workflowHistory.save();

    return res.json({
      success: true,
      message: "Execution tracked successfully",
      data: {
        executionId,
        userId: user._id,
        email,
        timestamp: new Date().toISOString(),
      },
    });
  } catch (error) {
    return handleControllerError(
      error,
      res,
      "trackExecution",
      ERROR_MESSAGES.INTERNAL_SERVER_ERROR
    );
  }
}

export async function checkPendingWorkflows(
  req: Request,
  res: Response
): Promise<Response> {
  try {
    const { userId } = req.params;

    // Validate required fields
    if (!userId) {
      return res.status(400).json({
        success: false,
        message: "Missing required parameter: userId",
      });
    }

    // Validate userId format (should be a valid ObjectId string)
    if (!mongoose.Types.ObjectId.isValid(userId)) {
      return res.status(400).json({
        success: false,
        message: "Invalid userId format",
      });
    }

    // Convert string userId to ObjectId for database query
    const userObjectId = new mongoose.Types.ObjectId(userId);

    // Find all pending workflows for this user
    const pendingWorkflows = await WorkflowHistory.find({
      userId: userObjectId,
      status: "pending",
    });

    if (pendingWorkflows.length === 0) {
      return res.json({
        success: true,
        message: "No pending workflows found",
        data: {
          hasPendingWorkflows: false,
          pendingCount: 0,
          message: null,
        },
      });
    }

    // Send socket notification for each pending workflow
    for (const workflow of pendingWorkflows) {
      try {
        notificationService.notifyUser(userId, "video-download-update", {
          type: "progress",
          status: "processing",
          message: "Your video creation is in progress",
          timestamp: new Date().toISOString(),
        });
      } catch (notificationError) {
        // Silently fail - notifications are best effort
      }
    }

    // Return pending workflow information
    return res.json({
      success: true,
      message: "Pending workflows found",
      data: {
        hasPendingWorkflows: true,
        pendingCount: pendingWorkflows.length,
        message: "Your video creation is in progress",
        workflows: pendingWorkflows.map((workflow) => ({
          executionId: workflow.executionId,
          createdAt: workflow.createdAt,
          email: workflow.email,
        })),
      },
    });
  } catch (error) {
    return handleControllerError(
      error,
      res,
      "checkPendingWorkflows",
      ERROR_MESSAGES.INTERNAL_SERVER_ERROR
    );
  }
}

// ==================== VIDEO DOWNLOAD ====================
export async function download(req: Request, res: Response): Promise<Response> {
  try {
    const { videoUrl, email, title, executionId, scheduleId, trendIndex, videoType } =
      req.body;

    // Validate required fields
    const requiredFields = ["videoUrl", "email", "title"];
    for (const field of requiredFields) {
      if (!req.body[field] || String(req.body[field]).trim() === "") {
        return res.status(400).json({
          success: false,
          message: `Missing required field: ${field}`,
        });
      }
    }

    // Get user ID for notifications
    const user = await videoService.getUserByEmail(email);
    if (!user) {
      return res.status(404).json({
        success: false,
        message: "User not found",
      });
    }

    // Send initial notification
    notificationService.notifyVideoDownloadProgress(
      user._id.toString(),
      "download",
      "progress",
      {
        message: "Starting video download...",
      }
    );

    // Download and upload video
    const result = await videoService.downloadAndUploadVideo(
      videoUrl,
      email,
      title,
      videoType
    );

    // Mark whether this video was auto-generated (scheduled) or manual
    await updateVideoAutoGeneratedFlag(
      result.videoId,
      scheduleId,
      videoService
    );

    // Handle captions from request or pending captions
    await handleVideoCaptions(
      result.videoId,
      email,
      title,
      (req.body as any)?.captions,
      videoService
    );

    // Update workflow history if executionId is provided
    await updateWorkflowHistoryStatus(executionId, "completed");

    // Send success notification
    notificationService.notifyVideoDownloadProgress(
      user._id.toString(),
      "complete",
      "success",
      {
        message: "Video downloaded and uploaded successfully!",
        videoId: result.videoId,
        title: result.title,
        size: result.size,
      }
    );

    // If schedule context is provided, mark schedule item completed and trigger auto-posting
    if (scheduleId && (trendIndex === 0 || Number.isInteger(trendIndex))) {
      // Run asynchronously; do not delay the response
      handleScheduleAutoPosting(
        scheduleId,
        trendIndex,
        result.videoId,
        videoUrl,
        result.title,
        user._id.toString(),
        videoService
      ).catch(() => {
        // Silently fail - async operation
      });
    }

    return res.json({
      success: true,
      message: "Video downloaded and uploaded successfully",
      data: result,
    });
  } catch (e: any) {
    // If schedule context is present, mark schedule item as failed
    await markScheduleAsFailed(
      (req.body as any)?.scheduleId,
      (req.body as any)?.trendIndex
    );

    // Update workflow history as failed if executionId is provided
    await updateWorkflowHistoryStatus(
      (req.body as any)?.executionId,
      "failed",
      e.message || "Video download failed"
    );

    // Send error notification if we have user info
    await sendErrorNotification(
      (req.body as any)?.email,
      e.message || "Unknown error occurred",
      videoService
    );

    return res
      .status(500)
      .json({ success: false, message: e.message || "Internal server error" });
  }
}

// ==================== VIDEO STATUS & MANAGEMENT ====================
export async function updateStatus(
  req: Request,
  res: Response
): Promise<Response> {
  try {
    const { videoId, status, metadata } = req.body;

    if (!videoId || !status) {
      return res.status(400).json({
        success: false,
        message: "Video ID and status are required",
      });
    }

    if (!VALID_VIDEO_STATUSES.includes(status as any)) {
      return res.status(400).json({
        success: false,
        message: `Invalid status. Must be one of: ${VALID_VIDEO_STATUSES.join(
          ", "
        )}`,
      });
    }

    const updatedVideo = await videoService.updateVideoStatus(videoId, status);

    if (!updatedVideo) {
      return res.status(404).json({
        success: false,
        message: ERROR_MESSAGES.VIDEO_NOT_FOUND,
      });
    }

    // Update metadata if provided
    if (metadata) {
      await videoService.updateVideoMetadata(videoId, metadata);
    }

    return res.json({
      success: true,
      message: "Video status updated successfully",
      data: {
        videoId: updatedVideo.videoId,
        status: updatedVideo.status,
        updatedAt: updatedVideo.updatedAt,
      },
    });
  } catch (error) {
    return handleControllerError(
      error,
      res,
      "updateStatus",
      ERROR_MESSAGES.INTERNAL_SERVER_ERROR
    );
  }
}

// ==================== VIDEO DELETION ====================
export async function deleteVideo(
  req: Request,
  res: Response
): Promise<Response> {
  try {
    const payload = requireAuth(req);
    const { videoId } = req.body;

    if (!videoId) {
      return res.status(400).json({
        success: false,
        message: "Video ID is required",
      });
    }

    const video = await videoService.getVideo(videoId);
    if (!video) {
      return res.status(404).json({
        success: false,
        message: ERROR_MESSAGES.VIDEO_NOT_FOUND,
      });
    }

    // Verify video belongs to user
    if (video.userId && video.userId.toString() !== payload.userId) {
      return res.status(403).json({
        success: false,
        message: ERROR_MESSAGES.UNAUTHORIZED,
      });
    }

    const deleted = await videoService.deleteVideo(videoId);

    if (!deleted) {
      return res.status(500).json({
        success: false,
        message: "Failed to delete video",
      });
    }

    return res.json({
      success: true,
      message: "Video deleted successfully",
    });
  } catch (error) {
    return handleControllerError(
      error,
      res,
      "deleteVideo",
      ERROR_MESSAGES.INTERNAL_SERVER_ERROR
    );
  }
}

/**
 * Delete a video by ID (RESTful DELETE endpoint)
 * DELETE /api/video/:videoId
 */
export async function deleteVideoById(
  req: Request,
  res: Response
): Promise<Response> {
  try {
    const payload = requireAuth(req);
    const { videoId } = req.params;

    if (!videoId) {
      return res.status(400).json({
        success: false,
        message: "Video ID is required",
      });
    }

    // Get video to verify ownership
    const video = await videoService.getVideo(videoId);
    if (!video) {
      return res.status(404).json({
        success: false,
        message: ERROR_MESSAGES.VIDEO_NOT_FOUND,
      });
    }

    // Verify video belongs to user
    if (video.userId && video.userId.toString() !== payload.userId) {
      return res.status(403).json({
        success: false,
        message: ERROR_MESSAGES.UNAUTHORIZED,
      });
    }

    // Delete video from S3 and database
    const deleted = await videoService.deleteVideo(videoId);

    if (!deleted) {
      return res.status(500).json({
        success: false,
        message: "Failed to delete video",
      });
    }

    return res.json({
      success: true,
      message: "Video deleted successfully",
      data: {
        videoId: videoId,
        deletedAt: new Date().toISOString(),
      },
    });
  } catch (error) {
    return handleControllerError(
      error,
      res,
      "deleteVideoById",
      ERROR_MESSAGES.INTERNAL_SERVER_ERROR
    );
  }
}

// ==================== VIDEO PROXY ====================
export async function downloadProxy(
  req: Request,
  res: Response
): Promise<Response> {
  try {
    const videoUrl = String(req.query.url || "");
    if (!videoUrl) {
      return res.status(400).json({
        success: false,
        message: "Video URL is required",
      });
    }

    // Get token from query parameter or Authorization header
    const tokenFromQuery = String(req.query.token || "").trim();
    const tokenFromHeader = extractAccessToken(req) || "";

    // Use token from query parameter if provided, otherwise fall back to header
    const token = tokenFromQuery || tokenFromHeader;

    if (!token) {
      return res.status(401).json({
        success: false,
        message:
          "Access token is required (provide via ?token=xxx or Authorization header)",
      });
    }

    // Validate token
    try {
      const payload = authService.verifyToken(token);
      if (!payload) {
        return res.status(401).json({
          success: false,
          message: ERROR_MESSAGES.INVALID_ACCESS_TOKEN,
        });
      }

      // Optionally verify user exists
      const user = await authService.getCurrentUser(token);
      if (!user) {
        return res.status(401).json({
          success: false,
          message: ERROR_MESSAGES.USER_NOT_FOUND,
        });
      }
    } catch (authError: any) {
      return res.status(401).json({
        success: false,
        message: authError.message || ERROR_MESSAGES.INVALID_ACCESS_TOKEN,
      });
    }

    // Fetch the video from S3 (server-side, no CORS issues)
    const videoResponse = await fetch(videoUrl);

    if (!videoResponse.ok) {
      throw new Error(`Failed to fetch video: ${videoResponse.status}`);
    }

    // Get video data
    const videoBuffer = await videoResponse.arrayBuffer();
    const contentType =
      videoResponse.headers.get("content-type") || DEFAULT_VIDEO_CONTENT_TYPE;

    // Return the video as a downloadable file
    res.setHeader("Content-Type", contentType);
    res.setHeader("Content-Disposition", 'attachment; filename="video.mp4"');
    res.setHeader("Content-Length", videoBuffer.byteLength.toString());
    res.setHeader("Cache-Control", "no-cache");
    res.setHeader("Access-Control-Allow-Origin", "*");
    res.setHeader("Access-Control-Allow-Methods", "*");
    res.setHeader("Access-Control-Allow-Headers", "*");

    return res.status(200).send(Buffer.from(videoBuffer));
  } catch (error) {
    return handleControllerError(
      error,
      res,
      "downloadProxy",
      ERROR_MESSAGES.INTERNAL_SERVER_ERROR
    );
  }
}

// ==================== AVATARS & VOICES ====================
export async function getAvatars(
  req: Request,
  res: Response
): Promise<Response> {
  try {
    const token = extractAccessToken(req) || "";
    const user = await authService.getCurrentUser(token);
    if (!user) {
      return res.status(401).json({
        success: false,
        message: ERROR_MESSAGES.INVALID_ACCESS_TOKEN,
      });
    }

    const userObjectId = user._id;
    // Fetch custom avatars for user
    const customAvatars = await DefaultAvatar.find({ userId: userObjectId });
    // Fetch default avatars (no userId)
    const defaultAvatars = await DefaultAvatar.find({
      userId: { $exists: false },
      default: true,
    });

    return res.json({
      success: true,
      custom: customAvatars,
      default: defaultAvatars,
    });
  } catch (error) {
    return handleControllerError(
      error,
      res,
      "getAvatars",
      ERROR_MESSAGES.INTERNAL_SERVER_ERROR
    );
  }
}

export async function getVoices(
  req: Request,
  res: Response
): Promise<Response> {
  try {
    const token = extractAccessToken(req) || "";
    const user = await authService.getCurrentUser(token);
    if (!user) {
      return res.status(401).json({
        success: false,
        message: ERROR_MESSAGES.INVALID_ACCESS_TOKEN,
      });
    }

    const userObjectId = user._id;
    // Fetch custom voices for user
    const customVoices = await DefaultVoice.find({ userId: userObjectId });
    // Fetch default voices (no userId)
    const defaultVoices = await DefaultVoice.find({
      userId: { $exists: false },
      default: true,
    });

    return res.json({
      success: true,
      custom: customVoices,
      default: defaultVoices,
    });
  } catch (error) {
    return handleControllerError(
      error,
      res,
      "getVoices",
      ERROR_MESSAGES.INTERNAL_SERVER_ERROR
    );
  }
}

// ==================== PHOTO AVATAR CREATION ====================
export const createPhotoAvatarUpload = upload.single("image");

export async function createPhotoAvatar(
  req: Request & { file?: Express.Multer.File },
  res: Response
): Promise<Response> {
  try {
    const { age_group, name, gender, userId, ethnicity } = req.body;
    if (!req.file || !age_group || !name || !gender || !userId) {
      return res.status(400).json({
        success: false,
        message: "Missing required fields",
      });
    }

    // Check for active subscription
    const subscriptionService = new SubscriptionService();
    const subscription = await subscriptionService.getActiveSubscription(
      userId
    );
    if (!subscription) {
      return res.status(403).json({
        success: false,
        message: "Active subscription required to create photo avatars",
      });
    }

    // Use uploaded file path
    const tempImagePath = req.file.path;
    // Add job to BullMQ queue
    await photoAvatarQueue.add("create-photo-avatar", {
      imagePath: tempImagePath,
      age_group,
      name,
      gender,
      userId,
      ethnicity,
      mimeType: req.file.mimetype,
    });

    return res.json({
      success: true,
      message:
        "Photo avatar creation started. You will be notified when ready.",
    });
  } catch (error) {
    return handleControllerError(
      error,
      res,
      "createPhotoAvatar",
      ERROR_MESSAGES.INTERNAL_SERVER_ERROR
    );
  }
}

// ==================== VIDEO CREATION ====================
export async function createVideo(
  req: Request,
  res: Response
): Promise<Response> {
  try {
    // ⚠️ CRITICAL: Check video limit FIRST before any processing or webhook calls
    const email = String(req.body.email || "").trim();
    if (!email) {
      return res.status(400).json({
        success: false,
        message: "Email is required to check subscription limits",
      });
    }

    const user = await videoService.getUserByEmail(email);
    if (!user) {
      return res.status(404).json({
        success: false,
        message: ERROR_MESSAGES.USER_NOT_FOUND,
      });
    }

    const videoLimit = await checkVideoCreationLimit(email, videoService);

    if (!videoLimit.canCreate) {
      return res.status(429).json({
        success: false,
        message: `Video limit reached. You have used ${
          videoLimit.used || 0
        } out of ${
          videoLimit.limit || 0
        } videos this month. Your subscription will renew monthly.`,
        data: {
          limit: videoLimit.limit,
          remaining: videoLimit.remaining,
          used: videoLimit.used,
        },
      });
    }

    // Now proceed with field validation
    const requiredFields = [
      "prompt",
      "avatar",
      "name",
      "position",
      "companyName",
      "license",
      "tailoredFit",
      "socialHandles",
      "videoTopic",
      "topicKeyPoints",
      "city",
      "preferredTone",
      "callToAction",
      "email",
    ];
    const validation = validateRequiredFields(req.body, requiredFields);
    if (!validation.isValid) {
      return res.status(400).json({
        success: false,
        message: `${validation.missingField} is required`,
      });
    }

    const webhookUrl = process.env.VIDEO_CREATION_WEBHOOK_URL;
    if (!webhookUrl) {
      return res.status(500).json({
        success: false,
        message: "Video creation service is not configured",
      });
    }

    // Get language from body, userSettings, or default
   

    const body = req.body;
    let language = body.language;
    if (!language) {
      try {
        const userVideoSettingsService = new UserVideoSettingsService();
        const userSettings = await userVideoSettingsService.getUserVideoSettings(email);
        if (userSettings?.language) {
          language = userSettings.language;
        }
      } catch (langError) {
        // If userSettings fetch fails, continue with default
        console.error("Failed to fetch userSettings for language:", langError);
      }
    }
    // Use DEFAULT_LANGUAGE only as last resort
    language = language || DEFAULT_LANGUAGE;
    const webhookData = {
      prompt: body.prompt,
      avatar: body.avatar,
      name: body.name,
      position: body.position,
      companyName: body.companyName,
      license: body.license,
      tailoredFit: body.tailoredFit,
      socialHandles: body.socialHandles,
      videoTopic: body.videoTopic,
      topicKeyPoints: body.topicKeyPoints,
      city: body.city,
      preferredTone: body.preferredTone,
      zipCode: body.zipCode || null,
      zipKeyPoints: body.zipKeyPoints || null,
      callToAction: body.callToAction,
      email: body.email,
      language: language,
      timestamp: new Date().toISOString(),
      requestId: generateRequestId("video"),
    };

    // Generate and store DYNAMIC captions for manual/custom videos
    try {
      const topic = String(body.videoTopic || body.name || "").trim();
      const keyPoints = String(body.topicKeyPoints || body.prompt || "").trim();
      if (topic && keyPoints) {
        const userForCaptions = await videoService.getUserByEmail(body.email);
        if (userForCaptions) {
          const userContext = {
            name: body.name,
            position: body.position,
            companyName: body.companyName,
            city: body.city,
            socialHandles: body.socialHandles,
          };

          await storePendingCaptionsForDynamicGeneration(
            body.email,
            body.videoTopic || body.title || topic,
            topic,
            keyPoints,
            userContext,
            userForCaptions._id.toString(),
            [...SOCIAL_MEDIA_PLATFORMS]
          );
        } else {
          const userContext = {
            name: body.name,
            position: body.position,
            companyName: body.companyName,
            city: body.city,
            socialHandles: body.socialHandles,
          };

          await storeFallbackCaptions(
            body.email,
            body.videoTopic || body.title || topic,
            topic,
            keyPoints,
            userContext,
            body.language
          );
        }
      }
    } catch (capGenErr) {
      // Silently fail - captions are optional
    }

    // Send webhook request (response sent in callback)
    sendWebhookRequest(
      webhookUrl,
      webhookData,
      (webhookResult: any, statusCode: number) => {
        if (statusCode < 200 || statusCode >= 300) {
          res.status(502).json({
            success: false,
            message: "Failed to create video. Please try again later.",
            error: `Webhook error: ${statusCode}`,
          });
          return;
        }

        if (webhookResult.error) {
          res.status(500).json({
            success: false,
            message: "Internal server error. Please try again later.",
            error: webhookResult.error,
          });
          return;
        }

        res.status(200).json({
          success: true,
          message: "Video creation request submitted successfully",
          data: {
            requestId: webhookData.requestId,
            webhookResponse: webhookResult,
            timestamp: webhookData.timestamp,
            status: "pending",
          },
        });
      }
    );

    // Response will be sent in webhook callback
    // Return res to satisfy TypeScript return type (actual response sent asynchronously)
    return Promise.resolve(res);
  } catch (error) {
    return handleControllerError(
      error,
      res,
      "createVideo",
      "Internal server error. Please try again later."
    );
  }
}

// ==================== VIDEO GENERATION ====================
export async function generateVideo(req: Request, res: Response) {
  try {
    const body = req.body;

    // ⚠️ CRITICAL: Check video limit FIRST before any processing or webhook calls
    // This prevents n8n webhook from being called if user has reached their limit
    const email = String(body.email || "").trim();
    if (!email) {
      return res.status(400).json({
        success: false,
        message: "Email is required to check subscription limits",
      });
    }

    const user = await videoService.getUserByEmail(email);
    if (!user) {
      return res.status(404).json({
        success: false,
        message: "User not found",
      });
    }

    const videoLimit = await checkVideoCreationLimit(email, videoService);

    if (!videoLimit.canCreate) {
      return res.status(429).json({
        success: false,
        message: `Video limit reached. You have used ${
          videoLimit.used || 0
        } out of ${
          videoLimit.limit || 0
        } videos this month. Your subscription will renew monthly.`,
        data: {
          limit: videoLimit.limit,
          remaining: videoLimit.remaining,
          used: videoLimit.used,
        },
      });
    }

    // Now proceed with field validation
    const requiredFields = [
      "hook",
      "body",
      "conclusion",
      "company_name",
      "social_handles",
      "license",
      "avatar_title",
      "avatar_body",
      "avatar_conclusion",
      "email",
      "title",
    ];
    const validation = validateRequiredFields(body, requiredFields);
    if (!validation.isValid) {
      return res.status(400).json({
        success: false,
        message: `Missing or empty required field: ${validation.missingField}`,
        error: `Field ${validation.missingField} is required and cannot be empty`,
        receivedData: body,
      });
    }

    const webhookUrl = process.env.GENERATE_VIDEO_WEBHOOK_URL;
    if (!webhookUrl) {
      return res.status(500).json({
        success: false,
        message: "GENERATE_VIDEO_WEBHOOK_URL environment variable is not set",
      });
    }

    // Get energy profile settings - either from request body or user settings
    const { voiceEnergyParams, energyLevel } = await getVoiceEnergyParams(
      body,
      body.email
    );

    // Get avatar document and voice ID
    const avatarDoc = await DefaultAvatar.findOne({
      avatar_id: body.avatar_title,
    });
    const voice_id = await getVoiceIdFromAvatar(body.avatar_title);

    // Resolve avatar types for title/body/conclusion avatars
    const avatarIdsToResolve = [
      String(body.avatar_title || "").trim(),
      String(body.avatar_body || "").trim(),
      String(body.avatar_conclusion || "").trim(),
    ].filter(Boolean) as string[];

    const avatarTypeById = await resolveAvatarTypes(avatarIdsToResolve);

    // Get language code
    const languageCode = await getLanguageCode(body.language, body.email);

    // Store caption generation data for asynchronous processing after webhook
    try {
      const userForCaptions = await videoService.getUserByEmail(body.email);
      const userContext = {
        name: body.company_name,
        position: "Real Estate Professional",
        companyName: body.company_name,
        city: "Your City",
        socialHandles: body.social_handles,
      };

      if (userForCaptions) {
        await storePendingCaptionsForDynamicGeneration(
          body.email,
          body.title,
          body.title || body.hook,
          `${body.hook} ${body.body} ${body.conclusion}`,
          userContext,
          userForCaptions._id.toString(),
          [...SOCIAL_MEDIA_PLATFORMS]
        );
      } else {
        await PendingCaptions.findOneAndUpdate(
          { email: body.email, title: body.title },
          {
            email: body.email,
            title: body.title,
            topic: body.title || body.hook,
            keyPoints: `${body.hook} ${body.body} ${body.conclusion}`,
            userContext,
            isDynamic: false,
            isPending: true,
            captions: null,
          },
          { upsert: true, new: true }
        );
      }
    } catch (capGenErr) {
      // Silently fail - captions are optional
    }

    // Get userSettings for videoCaption (and save videoCaption if provided in body)
    let userSettings: any = null;
    try {
      const userVideoSettingsService = new UserVideoSettingsService();
      userSettings = await userVideoSettingsService.getUserVideoSettings(
        body.email
      );

      // Save videoCaption to user settings if provided in body
      if (
        body.videoCaption &&
        typeof body.videoCaption === "string" &&
        userSettings
      ) {
        userSettings.videoCaption = normalizeVideoCaptionForStorage(
          body.videoCaption
        );
        await userSettings.save();
      }
    } catch (captionSaveError: any) {
      // Don't fail the request if userSettings fetch or caption saving fails
      console.error(
        "Failed to fetch userSettings or save videoCaption:",
        captionSaveError
      );
    }

    const webhookData = {
      hook: {
        audio: body.hook,
        avatar: body.avatar_title,
        avatarType: avatarTypeById[String(body.avatar_title || "").trim()],
      },
      body: {
        audio: body.body,
        avatar: body.avatar_body,
        text: body.text,
        avatarType: avatarTypeById[String(body.avatar_body || "").trim()],
      },
      conclusion: {
        audio: body.conclusion,
        avatar: body.avatar_conclusion,
        avatarType: avatarTypeById[String(body.avatar_conclusion || "").trim()],
      },
      company_name: body.company_name,
      social_handles: body.social_handles,
      license: body.license,
      email: body.email,
      title: body.title,
      voice: voice_id, // backward compatibility
      voice_id: voice_id,
      isDefault: avatarDoc?.default,
      timestamp: new Date().toISOString(),
      fullAudio: body.full_audio_url,
      videoCaption: convertVideoCaptionToBoolean(userSettings?.videoCaption),
      ...(languageCode ? { language: languageCode } : {}), // Add language code if available
      // New voice energy parameters
      voiceEnergy: {
        stability: voiceEnergyParams.stability,
        similarity_boost: voiceEnergyParams.similarity_boost,
        style: voiceEnergyParams.style,
        use_speaker_boost: voiceEnergyParams.use_speaker_boost,
        speed: voiceEnergyParams.speed,
      },
      // Energy level for reference
      energyLevel: energyLevel,
      // Music URL from frontend (string .mp3) - passed directly to N8N
      ...(body.music && typeof body.music === "string"
        ? { music: body.music }
        : {}),
      // Optional schedule context for auto runs (forward to N8N)
      ...(body.scheduleId ? { scheduleId: body.scheduleId } : {}),
      ...(body.trendIndex !== undefined
        ? { trendIndex: Number(body.trendIndex) }
        : {}),
      ...(body.scheduleId !== undefined || body.trendIndex !== undefined
        ? { isScheduled: true }
        : {}),
    } as any;
    // Captions are now generated asynchronously after webhook completes
    const webhookPayload = webhookData;

    // Log schedule context if present
    if (
      webhookPayload.scheduleId !== undefined ||
      webhookPayload.trendIndex !== undefined
    ) {
    } else {
    }

    // Fire and forget: send request to n8n webhook and return immediately
    sendFireAndForgetWebhook(webhookUrl, webhookPayload);

    // Return immediately with request info
    return res.json({
      success: true,
      message: "Video generation started successfully",
      data: {
        status: "processing",
        timestamp: new Date().toISOString(),
        estimated_completion: new Date(
          Date.now() + ESTIMATED_COMPLETION_MINUTES * 60 * 1000
        ).toISOString(),
        note: "Video generation is running in the background. The video will be available when ready.",
      },
    });
  } catch (error) {
    return handleControllerError(
      error,
      res,
      "generateVideo",
      "Internal server error. Please try again later."
    );
  }
}

// ==================== TOPIC MANAGEMENT ====================
export async function getAllTopics(
  req: Request,
  res: Response
): Promise<Response> {
  try {
    const topics = await videoService.getAllTopics();

    return res.json({
      success: true,
      message: "Topics retrieved successfully",
      data: topics,
    });
  } catch (error) {
    return handleControllerError(
      error,
      res,
      "getAllTopics",
      ERROR_MESSAGES.INTERNAL_SERVER_ERROR
    );
  }
}

export async function getTopicByType(
  req: Request,
  res: Response
): Promise<Response> {
  try {
    const { topic } = req.params;

    if (!topic) {
      return res.status(400).json({
        success: false,
        message: "Topic parameter is required",
      });
    }

    const topicData = await videoService.getTopicByType(topic);

    if (!topicData) {
      return res.status(404).json({
        success: false,
        message: "Topic not found",
      });
    }

    return res.json({
      success: true,
      message: "Topic retrieved successfully",
      data: topicData,
    });
  } catch (error) {
    return handleControllerError(
      error,
      res,
      "getTopicByType",
      ERROR_MESSAGES.INTERNAL_SERVER_ERROR
    );
  }
}

export async function getTopicById(
  req: Request,
  res: Response
): Promise<Response> {
  try {
    const { id } = req.params;

    if (!id) {
      return res.status(400).json({
        success: false,
        message: "ID parameter is required",
      });
    }

    const topicData = await videoService.getTopicById(id);

    if (!topicData) {
      return res.status(404).json({
        success: false,
        message: "Topic not found",
      });
    }

    return res.json({
      success: true,
      message: "Topic retrieved successfully",
      data: topicData,
    });
  } catch (error) {
    return handleControllerError(
      error,
      res,
      "getTopicById",
      ERROR_MESSAGES.INTERNAL_SERVER_ERROR
    );
  }
}

// ==================== VIDEO NOTES ====================
/**
 * Update video note
 * PUT /api/video/:videoId/note
 */
export async function updateVideoNote(
  req: Request,
  res: Response
): Promise<Response> {
  try {
    const payload = requireAuth(req);
    const { videoId } = req.params;

    // Validate videoId parameter
    const videoIdValidation = videoIdParamSchema.safeParse({ videoId });
    if (!videoIdValidation.success) {
      const errors = formatValidationErrors(videoIdValidation.error);
      return res.status(400).json({
        success: false,
        message: "Video ID is required",
        errors,
      });
    }

    // Validate request body
    const validationResult = updateVideoNoteSchema.safeParse(req.body);
    if (!validationResult.success) {
      const errors = formatValidationErrors(validationResult.error);
      return res.status(400).json({
        success: false,
        message: "Validation failed",
        errors,
      });
    }

    const { note } = validationResult.data;

    // Get video to verify ownership
    const video = await videoService.getVideo(videoId);
    if (!video) {
      return res.status(404).json({
        success: false,
        message: ERROR_MESSAGES.VIDEO_NOT_FOUND,
      });
    }

    // Verify video belongs to user
    if (video.userId && video.userId.toString() !== payload.userId) {
      return res.status(403).json({
        success: false,
        message: ERROR_MESSAGES.UNAUTHORIZED,
      });
    }

    // Update video note
    const updatedVideo = await videoService.updateVideoNote(
      videoId,
      note ?? null
    );

    if (!updatedVideo) {
      return res.status(500).json({
        success: false,
        message: "Failed to update video note",
      });
    }

    return res.json({
      success: true,
      message: "Video note updated successfully",
      data: {
        videoId: updatedVideo.videoId,
        note: updatedVideo.note,
        updatedAt: updatedVideo.updatedAt,
      },
    });
  } catch (error) {
    return handleControllerError(
      error,
      res,
      "updateVideoNote",
      ERROR_MESSAGES.INTERNAL_SERVER_ERROR
    );
  }
}
