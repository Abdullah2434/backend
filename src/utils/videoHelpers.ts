import { Request } from "express";
import AuthService from "../services/auth.service";
import mongoose from "mongoose";
import {
  VALID_ENERGY_LEVELS,
  DEFAULT_ENERGY_LEVEL,
  LANGUAGE_MAP,
  DEFAULT_LANGUAGE,
  ESTIMATED_COMPLETION_MINUTES,
  SOCIAL_PLATFORMS,
} from "../constants/video.constants";
import { VOICE_ENERGY_PRESETS } from "../constants/voiceEnergy";

const authService = new AuthService();

// ==================== CONTROLLER HELPER FUNCTIONS ====================

/**
 * Require authentication from request
 */
export function requireAuth(req: Request) {
  const token = (req.headers.authorization || "").replace("Bearer ", "");
  if (!token) throw new Error("Access token is required");
  const payload = authService.verifyToken(token);
  if (!payload) throw new Error("Invalid or expired access token");
  return payload;
}

/**
 * Get current user from request
 */
export async function getCurrentUser(req: Request) {
  const token = req.headers.authorization?.replace("Bearer ", "") || "";
  return await authService.getCurrentUser(token);
}

/**
 * Extract token from request (query or header)
 */
export function extractToken(req: Request): string | null {
  const tokenFromQuery = String(req.query.token || "").trim();
  const tokenFromHeader = (req.headers.authorization || "")
    .replace("Bearer ", "")
    .trim();
  return tokenFromQuery || tokenFromHeader || null;
}

/**
 * Format video response with social media captions
 */
export function formatVideoResponse(video: any) {
  const captions = video.socialMediaCaptions || {};
  const socialMediaCaptions = {
    instagram_caption: captions.instagram_caption || null,
    facebook_caption: captions.facebook_caption || null,
    linkedin_caption: captions.linkedin_caption || null,
    twitter_caption: captions.twitter_caption || null,
    tiktok_caption: captions.tiktok_caption || null,
    youtube_caption: captions.youtube_caption || null,
  };

  return {
    id: video._id.toString(),
    videoId: video.videoId,
    title: video.title,
    status: video.status,
    autoGenerated: Boolean(video.autoGenerated),
    createdAt: video.createdAt,
    updatedAt: video.updatedAt,
    metadata: video.metadata,
    downloadUrl: video.downloadUrl || null,
    videoUrl: video.videoUrl || null,
    socialMediaCaptions: video.socialMediaCaptions ? socialMediaCaptions : null,
    note: video.note || null,
  };
}

/**
 * Validate ObjectId format
 */
export function isValidObjectId(id: string): boolean {
  return mongoose.Types.ObjectId.isValid(id);
}

/**
 * Convert string to ObjectId
 */
export function toObjectId(id: string): mongoose.Types.ObjectId {
  return new mongoose.Types.ObjectId(id);
}

/**
 * Check if schedule context is valid
 */
export function isValidScheduleContext(
  scheduleId?: string,
  trendIndex?: number
): boolean {
  return !!(
    scheduleId &&
    (trendIndex === 0 || Number.isInteger(trendIndex))
  );
}

/**
 * Map language name to code
 */
export function mapLanguageToCode(language?: string): string | undefined {
  if (!language) return undefined;
  const languageLower = String(language).toLowerCase().trim();
  return LANGUAGE_MAP[languageLower] || languageLower;
}

/**
 * Get energy level and voice params
 */
export function getEnergyLevelAndParams(
  energyLevel?: string,
  customVoiceEnergy?: string
): {
  energyLevel: string;
  voiceEnergyParams: (typeof VOICE_ENERGY_PRESETS)[keyof typeof VOICE_ENERGY_PRESETS];
} {
  let finalEnergyLevel = DEFAULT_ENERGY_LEVEL;
  let voiceEnergyParams: (typeof VOICE_ENERGY_PRESETS)[keyof typeof VOICE_ENERGY_PRESETS] =
    VOICE_ENERGY_PRESETS.mid;

  if (energyLevel && VALID_ENERGY_LEVELS.includes(energyLevel as any)) {
    finalEnergyLevel = energyLevel;
    voiceEnergyParams =
      VOICE_ENERGY_PRESETS[finalEnergyLevel as keyof typeof VOICE_ENERGY_PRESETS];
  } else if (
    customVoiceEnergy &&
    VALID_ENERGY_LEVELS.includes(customVoiceEnergy as any)
  ) {
    finalEnergyLevel = customVoiceEnergy;
    voiceEnergyParams =
      VOICE_ENERGY_PRESETS[finalEnergyLevel as keyof typeof VOICE_ENERGY_PRESETS];
  }

  return {
    energyLevel: finalEnergyLevel,
    voiceEnergyParams,
  };
}

/**
 * Build webhook data for create video
 */
export function buildCreateVideoWebhookData(body: any) {
  return {
    prompt: body.prompt,
    avatar: body.avatar,
    name: body.name,
    position: body.position,
    companyName: body.companyName,
    license: body.license,
    tailoredFit: body.tailoredFit,
    socialHandles: body.socialHandles,
    videoTopic: body.videoTopic,
    topicKeyPoints: body.topicKeyPoints,
    city: body.city,
    preferredTone: body.preferredTone,
    zipCode: body.zipCode || null,
    zipKeyPoints: body.zipKeyPoints || null,
    callToAction: body.callToAction,
    email: body.email,
    language: body.language || DEFAULT_LANGUAGE,
    timestamp: new Date().toISOString(),
    requestId: `video_${Date.now()}_${Math.random()
      .toString(36)
      .substr(2, 9)}`,
  };
}

/**
 * Build user context for dynamic posts
 */
export function buildUserContext(body: any) {
  return {
    name: body.name || body.company_name,
    position: body.position || "Real Estate Professional",
    companyName: body.companyName || body.company_name,
    city: body.city || "Your City",
    socialHandles: body.socialHandles || body.social_handles,
  };
}

/**
 * Calculate estimated completion time
 */
export function getEstimatedCompletionTime(): string {
  return new Date(
    Date.now() + ESTIMATED_COMPLETION_MINUTES * 60 * 1000
  ).toISOString();
}

/**
 * Determine HTTP status code based on error message
 */
export function getErrorStatus(error: Error): number {
  const message = error.message.toLowerCase();

  if (
    message.includes("access token") ||
    message.includes("token") ||
    message.includes("not authenticated") ||
    message.includes("unauthorized")
  ) {
    return 401;
  }
  if (message.includes("not found")) {
    return 404;
  }
  if (message.includes("invalid") || message.includes("required")) {
    return 400;
  }
  if (message.includes("subscription") || message.includes("limit")) {
    return 403;
  }
  return 500;
}

/**
 * Build video limit reached email content
 */
export function buildVideoLimitEmailContent(
  limit: number,
  remaining: number,
  used: number
): string {
  const frontendUrl = process.env.FRONTEND_URL || "https://www.edgeairealty.com";
  return `
    <h2>Video Limit Reached</h2>
    <p>You have reached your monthly video limit (${limit} videos per month).</p>
    <p>You have used ${used} out of ${limit} videos this month.</p>
    <p>Your subscription will renew monthly, allowing you to create more videos next month.</p>
    <p><a href="${frontendUrl}" target="_blank">Visit Dashboard</a></p>
  `;
}

/**
 * Build video limit response data
 */
export function buildVideoLimitResponseData(
  limit: number,
  remaining: number,
  used: number
) {
  return {
    limit,
    remaining,
    used,
  };
}

/**
 * Build video limit error message
 */
export function buildVideoLimitErrorMessage(
  limit: number,
  remaining: number,
  used: number
): string {
  return `Video limit reached. You have used ${used} out of ${limit} videos this month. Your subscription will renew monthly.`;
}

// ==================== SERVICE-LEVEL UTILITY FUNCTIONS ====================

/**
 * Get user's existing video titles
 */
export async function getUserExistingVideoTitles(
  userId: string,
  email: string
): Promise<string[]> {
  const Video = (await import("../models/Video")).default;
  const videos = await Video.find({ userId, email }).select("title");
  return videos.map((video: any) => video.title?.toLowerCase().trim() || "");
}

/**
 * Filter existing trends by comparing with user's existing video titles
 */
export function filterExistingTrends(
  trends: any[],
  existingTitles: string[]
): any[] {
  if (!existingTitles || existingTitles.length === 0) {
    return trends;
  }

  const normalizedExistingTitles = existingTitles.map((title) =>
    title.toLowerCase().trim()
  );

  return trends.filter((trend) => {
    const trendTitle = trend.description?.toLowerCase().trim() || "";
    return !normalizedExistingTitles.some((existingTitle) =>
      trendTitle.includes(existingTitle) || existingTitle.includes(trendTitle)
    );
  });
}
